generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum ServiceType {
  SONARR
  RADARR
  PROWLARR
}

model User {
  id                  String                @id @default(cuid())
  username            String                @unique
  hashedPassword      String?               // Optional: users can authenticate via OIDC or passkeys
  mustChangePassword  Boolean               @default(false)
  failedLoginAttempts Int                   @default(0)
  lockedUntil         DateTime?
  encryptedTmdbApiKey String?
  tmdbEncryptionIv    String?
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  sessions            Session[]
  oidcAccounts        OIDCAccount[]
  webauthnCredentials WebAuthnCredential[]
  trashSettings        TrashSettings?
  serviceInstances     ServiceInstance[]
  personalCustomFormats PersonalCustomFormat[]
}

model Session {
  id        String   @id
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt]) // For cleanup queries
  @@map("sessions")
}

model ServiceTag {
  id        String            @id @default(cuid())
  name      String            @unique
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  instances ServiceInstanceTag[]
}

model ServiceInstance {
  id              String              @id @default(cuid())
  userId          String
  service         ServiceType
  label           String
  baseUrl         String
  encryptedApiKey String
  encryptionIv    String
  isDefault       Boolean             @default(false)
  enabled         Boolean             @default(true)
  defaultQualityProfileId Int?
  defaultLanguageProfileId Int?
  defaultRootFolderPath String?
  defaultSeasonFolder Boolean?
  storageGroupId  String?             // Group instances sharing same storage for accurate disk stats
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations
  user                        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags                        ServiceInstanceTag[]
  trashSyncHistory            TrashSyncHistory[]
  trashBackups                TrashBackup[]
  trashSchedules              TrashSyncSchedule[]
  qualityProfileOverrides     InstanceQualityProfileOverride[]
  qualityProfileMappings      TemplateQualityProfileMapping[]
  deploymentHistory           TemplateDeploymentHistory[]
  standaloneCFDeployments     StandaloneCFDeployment[]
  huntConfig                  HuntConfig?
  huntLogs                    HuntLog[]
  personalCFDeployments       PersonalCFDeployment[]

  @@index([service])
  @@index([userId])
}

model ServiceInstanceTag {
  instanceId String
  tagId      String
  assignedAt DateTime @default(now())

  instance ServiceInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  tag      ServiceTag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([instanceId, tagId])
}

// OIDC Provider Configuration (stored in database, managed via UI)
// Singleton table: Only one OIDC provider is supported per installation (enforced at database level)
model OIDCProvider {
  id                      Int      @id @default(1) // Singleton: always 1
  displayName             String   // Display name shown on login button
  clientId                String
  encryptedClientSecret   String   // AES-256-GCM encrypted
  clientSecretIv          String   // Initialization vector for encryption
  issuer                  String   // OIDC issuer URL for discovery
  redirectUri             String   // Callback URL
  scopes                  String   @default("openid,email,profile") // Comma-separated
  enabled                 Boolean  @default(true)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@map("oidc_providers")
}

// OIDC Account linking users to their OIDC identity
model OIDCAccount {
  id              String   @id @default(cuid())
  userId          String
  providerUserId  String   // The user ID from the OIDC provider (sub claim)
  providerEmail   String?  // Email from the OIDC provider
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerUserId])
  @@index([userId])
  @@map("oidc_accounts")
}

// WebAuthn credentials for passkey authentication
model WebAuthnCredential {
  id                String   @id // Base64url encoded credential ID
  userId            String
  publicKey         String   // Base64url encoded public key
  counter           Int      @default(0) // Signature counter for security
  transports        String?  // JSON array of allowed transports (usb, nfc, ble, internal)
  backedUp          Boolean  @default(false) // Whether credential is backed up to cloud
  friendlyName      String?  // User-provided name (e.g., "iPhone", "YubiKey")
  createdAt         DateTime @default(now())
  lastUsedAt        DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("webauthn_credentials")
}

enum BackupIntervalType {
  DISABLED
  HOURLY
  DAILY
  WEEKLY
}

// Backup settings (singleton table, only one row)
model BackupSettings {
  id                Int                 @id @default(1)
  enabled           Boolean             @default(false)
  intervalType      BackupIntervalType  @default(DISABLED)
  intervalValue     Int                 @default(24) // Hours for HOURLY, days for DAILY (1-7), 1 for WEEKLY
  retentionCount    Int                 @default(7)  // Number of scheduled backups to keep
  lastRunAt         DateTime?
  nextRunAt         DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  // Encrypted backup password (used for encrypting/decrypting backups)
  // If not set, falls back to BACKUP_PASSWORD env var
  encryptedPassword String?
  passwordIv        String?

  // Optional: Include TRaSH instance backups (ARR config snapshots)
  // When enabled, includes non-expired backups from last 7 days
  // These can be large but enable rollback capability after restore
  includeTrashBackups Boolean @default(false)

  @@map("backup_settings")
}

// System-wide settings (singleton table, only one row)
// These settings affect the entire application and may require restart to take effect
model SystemSettings {
  id                Int       @id @default(1)

  // Port configuration
  // These override the default ports (API: 3001, Web: 3000)
  // Requires container restart to take effect
  apiPort           Int       @default(3001)
  webPort           Int       @default(3000)

  // Listen address configuration
  // Default: 0.0.0.0 (all interfaces) for Docker compatibility
  // Options: 127.0.0.1 (localhost only), 0.0.0.0 (all interfaces), or specific IP
  // Requires container restart to take effect
  listenAddress     String    @default("0.0.0.0")

  // Application metadata
  appName           String    @default("Arr Dashboard")

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("system_settings")
}

// ============================================================================
// TRaSH Guides Integration Models
// ============================================================================

// TRaSH Guides cache storage for fetched JSON data from GitHub
model TrashCache {
  id            String      @id @default(cuid())
  serviceType   ServiceType // RADARR, SONARR
  configType    String      // CUSTOM_FORMATS, CF_GROUPS, QUALITY_SIZE, NAMING
  data          String      // JSON blob (will be compressed in application layer)
  version       Int         @default(1)
  commitHash    String?     // TRaSH Guides GitHub commit hash at time of fetch
  fetchedAt     DateTime    @default(now())
  lastCheckedAt DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@unique([serviceType, configType])
  @@index([serviceType, configType])
  @@index([commitHash])
  @@map("trash_cache")
}

// User-created templates for TRaSH configurations
model TrashTemplate {
  id          String      @id @default(cuid())
  userId      String
  name        String
  description String?
  serviceType ServiceType // RADARR, SONARR
  configData  String      // JSON blob with user customizations
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?   // Soft delete

  // Source Quality Profile Information
  sourceQualityProfileTrashId String? // TRaSH quality profile trash_id this template was created from
  sourceQualityProfileName    String? // TRaSH quality profile name (e.g., "HD Bluray + WEB")

  // Phase 3: Versioning & Metadata
  trashGuidesCommitHash    String?   // TRaSH Guides commit hash at time of import
  trashGuidesVersion       String?   // Semantic version if available
  importedAt               DateTime  @default(now())
  lastSyncedAt             DateTime? // Last time template was synced with TRaSH Guides

  // Phase 3: Customization Tracking
  hasUserModifications     Boolean   @default(false) // True if user has modified scores/selections
  modifiedFields           String?   // JSON array: ["scores", "cf_selections", "conditions"]
  lastModifiedAt           DateTime?
  lastModifiedBy           String?   // userId who made last modification

  // Phase 3: Change History (optional, for audit trail)
  changeLog                String?   // JSON array of change records

  // Phase 3: Instance-specific Overrides
  instanceOverrides        String?   // JSON object: { [instanceId]: { cfOverrides, scoreOverrides } }

  syncHistory               TrashSyncHistory[]
  schedules                 TrashSyncSchedule[]
  qualityProfileMappings    TemplateQualityProfileMapping[]
  deploymentHistory         TemplateDeploymentHistory[]

  @@index([userId])
  @@index([serviceType])
  @@index([trashGuidesCommitHash])
  @@index([lastSyncedAt])
  @@index([deletedAt]) // For soft delete queries
  @@map("trash_templates")
}

// Sync operation history and audit log
model TrashSyncHistory {
  id          String    @id @default(cuid())
  instanceId  String
  templateId  String?
  userId      String
  syncType    String    // MANUAL, SCHEDULED
  status      String    // SUCCESS, PARTIAL_SUCCESS, FAILED
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  duration    Int?      // seconds

  // Sync statistics
  configsApplied   Int @default(0)
  configsFailed    Int @default(0)
  configsSkipped   Int @default(0)

  // Detailed sync data (JSON blobs)
  appliedConfigs String  // JSON array of applied config IDs
  failedConfigs  String? // JSON array with error details
  errorLog       String? // Full error log

  // Rollback reference
  backupId       String?
  rolledBack     Boolean @default(false)
  rolledBackAt   DateTime?

  instance   ServiceInstance   @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  template   TrashTemplate?    @relation(fields: [templateId], references: [id], onDelete: SetNull)
  backup     TrashBackup?      @relation(fields: [backupId], references: [id], onDelete: SetNull)

  @@index([instanceId])
  @@index([templateId])
  @@index([userId])
  @@index([startedAt])
  @@map("trash_sync_history")
}

// Backup snapshots of instance configs before sync operations
model TrashBackup {
  id         String      @id @default(cuid())
  instanceId String
  userId     String
  backupData String      // JSON blob (compressed) - full instance config snapshot
  createdAt  DateTime    @default(now())
  expiresAt  DateTime?   // Auto-delete after retention period

  instance          ServiceInstance             @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  syncHistory       TrashSyncHistory[]
  deploymentHistory TemplateDeploymentHistory[]

  @@index([instanceId])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("trash_backups")
}

// Scheduled sync configuration for automated TRaSH updates
model TrashSyncSchedule {
  id          String      @id @default(cuid())
  instanceId  String?
  templateId  String?
  userId      String
  enabled     Boolean     @default(true)

  // Schedule configuration
  frequency   String      // DAILY, WEEKLY, MONTHLY
  lastRunAt   DateTime?
  nextRunAt   DateTime?

  // Sync behavior
  autoApply   Boolean     @default(false) // Auto-apply or just notify
  notifyUser  Boolean     @default(true)

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  instance ServiceInstance? @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  template TrashTemplate?   @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([instanceId])
  @@index([templateId])
  @@index([nextRunAt])
  @@map("trash_sync_schedules")
}

// User preferences for TRaSH Guides feature
model TrashSettings {
  id                 String   @id @default(cuid())
  userId             String   @unique

  // Update check settings
  checkFrequency     Int      @default(12) // hours
  autoRefreshCache   Boolean  @default(true)

  // Notification preferences
  notifyOnUpdates    Boolean  @default(true)
  notifyOnSyncFail   Boolean  @default(true)

  // Backup settings
  backupRetention    Int      @default(10) // number of backups to keep per instance
  backupRetentionDays Int     @default(30) // days before backup auto-expires (0 = never expire)

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("trash_settings")
}

// Template to Quality Profile Mapping
// Tracks which quality profiles in Radarr/Sonarr instances are managed by which templates
// This enables proper detection of template-managed vs user-created profiles
model TemplateQualityProfileMapping {
  id                  String   @id @default(cuid())
  templateId          String   // The TRaSH template managing this profile
  instanceId          String   // The Radarr/Sonarr instance
  qualityProfileId    Int      // The quality profile ID in Radarr/Sonarr
  qualityProfileName  String   // The quality profile name for reference
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  lastSyncedAt        DateTime @default(now())

  // Sync strategy for this specific instance deployment
  // "auto" = automatically apply TRaSH updates to this instance
  // "manual" = user must manually trigger sync
  // "notify" = notify user of updates but don't auto-apply
  syncStrategy        String   @default("notify")

  template TrashTemplate      @relation(fields: [templateId], references: [id], onDelete: Cascade)
  instance ServiceInstance    @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@unique([instanceId, qualityProfileId])
  @@index([templateId])
  @@index([instanceId])
  @@index([templateId, instanceId])
  @@map("template_quality_profile_mappings")
}

// Instance-level quality profile score overrides
// Tracks manual score changes made directly to instance quality profiles
// These take precedence over template scores during sync operations
model InstanceQualityProfileOverride {
  id                  String   @id @default(cuid())
  instanceId          String
  qualityProfileId    Int      // The Radarr/Sonarr quality profile ID
  customFormatId      Int      // The Radarr/Sonarr custom format ID
  score               Int      // The overridden score
  userId              String   // User who made the override
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  instance ServiceInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@unique([instanceId, qualityProfileId, customFormatId])
  @@index([instanceId])
  @@index([instanceId, qualityProfileId])
  @@map("instance_quality_profile_overrides")
}

// Phase 4: Template Deployment History
model TemplateDeploymentHistory {
  id          String    @id @default(cuid())
  templateId  String
  instanceId  String
  userId      String

  // Deployment metadata
  deployedAt  DateTime  @default(now())
  deployedBy  String    // User ID or "system" for scheduled
  duration    Int?      // Duration in seconds

  // Deployment status
  status      String    // SUCCESS, PARTIAL_SUCCESS, FAILED, IN_PROGRESS, PARTIAL_UNDEPLOY

  // Deployment statistics
  appliedCFs      Int @default(0)  // Successfully applied custom formats
  failedCFs       Int @default(0)  // Failed custom format applications
  totalCFs        Int @default(0)  // Total custom formats in template
  conflictsCount  Int @default(0)  // Number of conflicts encountered

  // Detailed deployment data (JSON blobs)
  appliedConfigs      String?  // JSON array of successfully applied config details
  failedConfigs       String?  // JSON array with failure details and error messages
  conflictResolutions String?  // JSON array of how conflicts were resolved
  errors              String?  // JSON array of error messages
  warnings            String?  // JSON array of warning messages

  // Rollback capability
  backupId    String?   // Reference to backup created before deployment
  canRollback Boolean   @default(false)
  rolledBack  Boolean   @default(false)
  rolledBackAt DateTime?
  rolledBackBy String?

  // Additional metadata
  deploymentNotes String?  // User or system notes about deployment
  templateSnapshot String? // JSON snapshot of template config at deployment time

  // Relations
  template TrashTemplate    @relation(fields: [templateId], references: [id], onDelete: Cascade)
  instance ServiceInstance  @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  backup   TrashBackup?     @relation(fields: [backupId], references: [id], onDelete: SetNull)

  @@index([templateId])
  @@index([instanceId])
  @@index([userId])
  @@index([deployedAt])
  @@index([status])
  @@map("template_deployment_history")
}

// Standalone Custom Format Deployment Tracking
// Tracks CFs deployed via the Custom Formats tab (outside of templates)
// Enables update notifications when TRaSH Guides updates these CFs
model StandaloneCFDeployment {
  id          String      @id @default(cuid())
  userId      String
  instanceId  String
  cfTrashId   String      // TRaSH custom format trash_id
  cfName      String      // CF name for display
  serviceType ServiceType // RADARR or SONARR
  commitHash  String      // TRaSH Guides commit hash at time of deployment
  deployedAt  DateTime    @default(now())

  // Relations
  instance ServiceInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@unique([instanceId, cfTrashId])
  @@index([userId])
  @@index([instanceId])
  @@index([commitHash])
  @@map("standalone_cf_deployments")
}

// ============================================================================
// Personal Custom Format Models
// User-created custom formats (not from TRaSH Guides)
// ============================================================================

model PersonalCustomFormat {
  id                              String   @id @default(cuid())
  userId                          String
  name                            String
  serviceType                     ServiceType // RADARR or SONARR
  includeCustomFormatWhenRenaming Boolean  @default(false)

  // Specification storage (JSON string)
  // Array of CustomFormatSpecification objects
  specifications                  String   // JSON array

  // Versioning
  version                         Int      @default(1)

  // Metadata
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt
  deletedAt                       DateTime? // Soft delete

  // Relations
  user        User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deployments PersonalCFDeployment[]

  @@unique([userId, name, serviceType]) // Prevent duplicate names per service type
  @@index([userId])
  @@index([serviceType])
  @@index([deletedAt])
  @@map("personal_custom_formats")
}

// Personal Custom Format Deployment Tracking
// Tracks personal CFs deployed to instances with version snapshots
model PersonalCFDeployment {
  id                    String               @id @default(cuid())
  userId                String
  personalCFId          String
  instanceId            String
  instanceCFId          Int                  // ID in the ARR instance
  deployedVersion       Int                  // Version deployed
  deployedSpecsSnapshot String               // JSON snapshot of specs at deployment time
  deployedAt            DateTime             @default(now())

  // Relations
  personalCF PersonalCustomFormat @relation(fields: [personalCFId], references: [id], onDelete: Cascade)
  instance   ServiceInstance      @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@unique([instanceId, personalCFId])
  @@index([userId])
  @@index([personalCFId])
  @@index([instanceId])
  @@map("personal_cf_deployments")
}

// ============================================================================
// Hunting Feature Models
// Automated discovery of missing content and quality upgrades
// ============================================================================

/// Hunt configuration per service instance (admin-only feature)
model HuntConfig {
  id                    String          @id @default(cuid())
  instanceId            String          @unique
  instance              ServiceInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  // Feature toggles
  huntMissingEnabled    Boolean         @default(false)
  huntUpgradesEnabled   Boolean         @default(false)

  // Missing content settings
  missingBatchSize      Int             @default(5)      // Items per cycle
  missingIntervalMins   Int             @default(60)     // Minutes between cycles

  // Upgrade settings
  upgradeBatchSize      Int             @default(3)      // Items per cycle
  upgradeIntervalMins   Int             @default(120)    // Minutes between cycles

  // Rate limiting
  hourlyApiCap          Int             @default(100)    // Max API calls per hour
  queueThreshold        Int             @default(25)     // Pause if queue exceeds this

  // === FILTER SETTINGS ===
  // Filter logic: how multiple filters combine
  filterLogic           String          @default("AND")  // "AND" or "OR"

  // Monitored filter
  monitoredOnly         Boolean         @default(true)   // Only hunt monitored content

  // Tag filters (JSON arrays of tag IDs)
  includeTags           String?                          // JSON: [1, 5, 12] - only hunt items with these tags
  excludeTags           String?                          // JSON: [3, 7] - skip items with these tags

  // Quality profile filters (JSON arrays of profile IDs)
  includeQualityProfiles String?                         // JSON: [1, 2] - only hunt items with these profiles
  excludeQualityProfiles String?                         // JSON: [3] - skip items with these profiles

  // Status filters (JSON array of status strings)
  // Sonarr: "continuing", "ended", "upcoming", "deleted"
  // Radarr: "tba", "announced", "inCinemas", "released", "deleted"
  includeStatuses       String?                          // JSON: ["continuing", "ended"]

  // Year range filter
  yearMin               Int?                             // Minimum release year (inclusive)
  yearMax               Int?                             // Maximum release year (inclusive)

  // Age threshold - skip content released recently (avoid hammering indexers)
  ageThresholdDays      Int?                             // Don't hunt content newer than X days

  // Re-search settings
  researchAfterDays     Int             @default(7)      // Re-search items after X days (0 = never re-search)

  // State tracking
  lastMissingHunt       DateTime?
  lastUpgradeHunt       DateTime?
  apiCallsThisHour      Int             @default(0)
  apiCallsResetAt       DateTime?

  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  // Relations
  searchHistory         HuntSearchHistory[]

  @@index([lastMissingHunt]) // For scheduling queries
  @@index([lastUpgradeHunt]) // For scheduling queries
  @@map("hunt_configs")
}

/// Log of hunt activity
model HuntLog {
  id            String          @id @default(cuid())
  instanceId    String
  instance      ServiceInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  huntType      String          // "missing" | "upgrade"
  itemsSearched Int             @default(0)
  itemsFound    Int             @default(0)

  // Details of what was searched (JSON arrays)
  searchedItems String?         // JSON: [{ id, title, type }]
  foundItems    String?         // JSON: [{ id, title, type, quality? }]

  status        String          // "completed" | "partial" | "skipped" | "error"
  message       String?         // Error message or skip reason
  durationMs    Int?            // Duration in milliseconds

  startedAt     DateTime        @default(now())
  completedAt   DateTime?

  @@index([instanceId, huntType, startedAt])
  @@index([startedAt])
  @@map("hunt_logs")
}

/// Track searched items to avoid re-searching too frequently
model HuntSearchHistory {
  id            String      @id @default(cuid())
  configId      String
  config        HuntConfig  @relation(fields: [configId], references: [id], onDelete: Cascade)

  // What was searched
  mediaType     String      // "movie" | "series" | "season" | "episode"
  mediaId       Int         // ID in Sonarr/Radarr (movieId, seriesId, episodeId)
  seasonNumber  Int?        // For season-level tracking (null for movies/series/episodes)
  title         String      // For display/debugging

  // Search tracking
  huntType      String      // "missing" | "upgrade"
  searchedAt    DateTime    @default(now())
  searchCount   Int         @default(1)  // How many times this item has been searched

  @@unique([configId, huntType, mediaType, mediaId, seasonNumber])
  @@index([configId, huntType, searchedAt])
  @@index([searchedAt])
  @@map("hunt_search_history")
}
